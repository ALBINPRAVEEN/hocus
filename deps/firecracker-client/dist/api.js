"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Firecracker API
 * RESTful public-facing API. The API is accessible through HTTP calls on specific URLs carrying JSON modeled data. The transport medium is a Unix Domain Socket.
 *
 * The version of the OpenAPI document: 1.1.2
 * Contact: compute-capsule@amazon.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultApi = exports.DefaultApiFactory = exports.DefaultApiFp = exports.DefaultApiAxiosParamCreator = exports.VmStateEnum = exports.SnapshotCreateParamsSnapshotTypeEnum = exports.MmdsConfigVersionEnum = exports.MemoryBackendBackendTypeEnum = exports.LoggerLevelEnum = exports.InstanceInfoStateEnum = exports.InstanceActionInfoActionTypeEnum = exports.DriveIoEngineEnum = exports.DriveCacheTypeEnum = exports.CpuTemplate = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * The CPU Template defines a set of flags to be disabled from the microvm so that the features exposed to the guest are the same as in the selected instance type. Works only on Intel.
 * @export
 * @enum {string}
 */
exports.CpuTemplate = {
    C3: 'C3',
    T2: 'T2',
    T2S: 'T2S',
    None: 'None'
};
exports.DriveCacheTypeEnum = {
    Unsafe: 'Unsafe',
    Writeback: 'Writeback'
};
exports.DriveIoEngineEnum = {
    Sync: 'Sync',
    Async: 'Async'
};
exports.InstanceActionInfoActionTypeEnum = {
    FlushMetrics: 'FlushMetrics',
    InstanceStart: 'InstanceStart',
    SendCtrlAltDel: 'SendCtrlAltDel'
};
exports.InstanceInfoStateEnum = {
    NotStarted: 'Not started',
    Running: 'Running',
    Paused: 'Paused'
};
exports.LoggerLevelEnum = {
    Error: 'Error',
    Warning: 'Warning',
    Info: 'Info',
    Debug: 'Debug'
};
exports.MemoryBackendBackendTypeEnum = {
    File: 'File',
    Uffd: 'Uffd'
};
exports.MmdsConfigVersionEnum = {
    V1: 'V1',
    V2: 'V2'
};
exports.SnapshotCreateParamsSnapshotTypeEnum = {
    Full: 'Full',
    Diff: 'Diff'
};
exports.VmStateEnum = {
    Paused: 'Paused',
    Resumed: 'Resumed'
};
/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
         * @summary Creates a full or diff snapshot. Post-boot only.
         * @param {SnapshotCreateParams} body The configuration used for creating a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createSnapshot', 'body', body);
            const localVarPath = `/snapshot/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a synchronous action.
         * @param {InstanceActionInfo} info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSyncAction: async (info, options = {}) => {
            // verify required parameter 'info' is not null or undefined
            (0, common_1.assertParamExists)('createSyncAction', 'info', info);
            const localVarPath = `/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(info, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the current balloon device configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeBalloonConfig: async (options = {}) => {
            const localVarPath = `/balloon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the latest balloon device statistics, only if enabled pre-boot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeBalloonStats: async (options = {}) => {
            const localVarPath = `/balloon/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns general information about an instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeInstance: async (options = {}) => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
         * @summary Gets the full VM configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportVmConfig: async (options = {}) => {
            const localVarPath = `/vm/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets the Firecracker version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirecrackerVersion: async (options = {}) => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
         * @summary Gets the machine configuration of the VM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMachineConfiguration: async (options = {}) => {
            const localVarPath = `/machine-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the MMDS data store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmds: async (options = {}) => {
            const localVarPath = `/mmds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
         * @summary Loads a snapshot. Pre-boot only.
         * @param {SnapshotLoadParams} body The configuration used for loading a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSnapshot: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('loadSnapshot', 'body', body);
            const localVarPath = `/snapshot/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device.
         * @param {BalloonUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBalloon: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('patchBalloon', 'body', body);
            const localVarPath = `/balloon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device statistics polling interval.
         * @param {BalloonStatsUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBalloonStatsInterval: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('patchBalloonStatsInterval', 'body', body);
            const localVarPath = `/balloon/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
         * @summary Updates the properties of a drive. Post-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {PartialDrive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGuestDriveByID: async (driveId, body, options = {}) => {
            // verify required parameter 'driveId' is not null or undefined
            (0, common_1.assertParamExists)('patchGuestDriveByID', 'driveId', driveId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('patchGuestDriveByID', 'body', body);
            const localVarPath = `/drives/{drive_id}`
                .replace(`{${"drive_id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the rate limiters applied to a network interface.
         * @summary Updates the rate limiters applied to a network interface. Post-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {PartialNetworkInterface} body A subset of the guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGuestNetworkInterfaceByID: async (ifaceId, body, options = {}) => {
            // verify required parameter 'ifaceId' is not null or undefined
            (0, common_1.assertParamExists)('patchGuestNetworkInterfaceByID', 'ifaceId', ifaceId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('patchGuestNetworkInterfaceByID', 'body', body);
            const localVarPath = `/network-interfaces/{iface_id}`
                .replace(`{${"iface_id"}}`, encodeURIComponent(String(ifaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
         * @summary Partially updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] A subset of Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMachineConfiguration: async (body, options = {}) => {
            const localVarPath = `/machine-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates the MMDS data store.
         * @param {object} [body] The MMDS data store patch JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMmds: async (body, options = {}) => {
            const localVarPath = `/mmds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the desired state (Paused or Resumed) for the microVM.
         * @summary Updates the microVM state.
         * @param {Vm} body The microVM state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVm: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('patchVm', 'body', body);
            const localVarPath = `/vm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
         * @summary Creates or updates a balloon device.
         * @param {Balloon} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBalloon: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('putBalloon', 'body', body);
            const localVarPath = `/balloon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
         * @summary Creates or updates the boot source. Pre-boot only.
         * @param {BootSource} body Guest boot source properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestBootSource: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('putGuestBootSource', 'body', body);
            const localVarPath = `/boot-source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
         * @summary Creates or updates a drive. Pre-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {Drive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestDriveByID: async (driveId, body, options = {}) => {
            // verify required parameter 'driveId' is not null or undefined
            (0, common_1.assertParamExists)('putGuestDriveByID', 'driveId', driveId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('putGuestDriveByID', 'body', body);
            const localVarPath = `/drives/{drive_id}`
                .replace(`{${"drive_id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new network interface with ID specified by iface_id path parameter.
         * @summary Creates a network interface. Pre-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {NetworkInterface} body Guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestNetworkInterfaceByID: async (ifaceId, body, options = {}) => {
            // verify required parameter 'ifaceId' is not null or undefined
            (0, common_1.assertParamExists)('putGuestNetworkInterfaceByID', 'ifaceId', ifaceId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('putGuestNetworkInterfaceByID', 'body', body);
            const localVarPath = `/network-interfaces/{iface_id}`
                .replace(`{${"iface_id"}}`, encodeURIComponent(String(ifaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
         * @summary Creates/updates a vsock device. Pre-boot only.
         * @param {Vsock} body Guest vsock properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestVsock: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('putGuestVsock', 'body', body);
            const localVarPath = `/vsock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Initializes the logger by specifying a named pipe or a file for the logs output.
         * @param {Logger} body Logging system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLogger: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('putLogger', 'body', body);
            const localVarPath = `/logger`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
         * @summary Updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMachineConfiguration: async (body, options = {}) => {
            const localVarPath = `/machine-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Initializes the metrics system by specifying a named pipe or a file for the metrics output.
         * @param {Metrics} body Metrics system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMetrics: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('putMetrics', 'body', body);
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a MMDS (Microvm Metadata Service) data store.
         * @param {object} [body] The MMDS data store as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMmds: async (body, options = {}) => {
            const localVarPath = `/mmds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
         * @summary Set MMDS configuration. Pre-boot only.
         * @param {MmdsConfig} body The MMDS configuration as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMmdsConfig: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('putMmdsConfig', 'body', body);
            const localVarPath = `/mmds/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DefaultApiAxiosParamCreator = DefaultApiAxiosParamCreator;
/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DefaultApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
         * @summary Creates a full or diff snapshot. Post-boot only.
         * @param {SnapshotCreateParams} body The configuration used for creating a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSnapshot(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSnapshot(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a synchronous action.
         * @param {InstanceActionInfo} info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSyncAction(info, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSyncAction(info, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns the current balloon device configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeBalloonConfig(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeBalloonConfig(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns the latest balloon device statistics, only if enabled pre-boot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeBalloonStats(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeBalloonStats(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns general information about an instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeInstance(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeInstance(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
         * @summary Gets the full VM configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportVmConfig(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportVmConfig(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets the Firecracker version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirecrackerVersion(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirecrackerVersion(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
         * @summary Gets the machine configuration of the VM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMachineConfiguration(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMachineConfiguration(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the MMDS data store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmds(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmds(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
         * @summary Loads a snapshot. Pre-boot only.
         * @param {SnapshotLoadParams} body The configuration used for loading a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadSnapshot(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadSnapshot(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device.
         * @param {BalloonUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBalloon(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchBalloon(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device statistics polling interval.
         * @param {BalloonStatsUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBalloonStatsInterval(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchBalloonStatsInterval(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
         * @summary Updates the properties of a drive. Post-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {PartialDrive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGuestDriveByID(driveId, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGuestDriveByID(driveId, body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates the rate limiters applied to a network interface.
         * @summary Updates the rate limiters applied to a network interface. Post-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {PartialNetworkInterface} body A subset of the guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGuestNetworkInterfaceByID(ifaceId, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGuestNetworkInterfaceByID(ifaceId, body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
         * @summary Partially updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] A subset of Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMachineConfiguration(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMachineConfiguration(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates the MMDS data store.
         * @param {object} [body] The MMDS data store patch JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMmds(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMmds(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the desired state (Paused or Resumed) for the microVM.
         * @summary Updates the microVM state.
         * @param {Vm} body The microVM state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchVm(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchVm(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
         * @summary Creates or updates a balloon device.
         * @param {Balloon} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBalloon(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBalloon(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
         * @summary Creates or updates the boot source. Pre-boot only.
         * @param {BootSource} body Guest boot source properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuestBootSource(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuestBootSource(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
         * @summary Creates or updates a drive. Pre-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {Drive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuestDriveByID(driveId, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuestDriveByID(driveId, body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates new network interface with ID specified by iface_id path parameter.
         * @summary Creates a network interface. Pre-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {NetworkInterface} body Guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuestNetworkInterfaceByID(ifaceId, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuestNetworkInterfaceByID(ifaceId, body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
         * @summary Creates/updates a vsock device. Pre-boot only.
         * @param {Vsock} body Guest vsock properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuestVsock(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuestVsock(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Initializes the logger by specifying a named pipe or a file for the logs output.
         * @param {Logger} body Logging system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLogger(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLogger(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
         * @summary Updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMachineConfiguration(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMachineConfiguration(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Initializes the metrics system by specifying a named pipe or a file for the metrics output.
         * @param {Metrics} body Metrics system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMetrics(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMetrics(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a MMDS (Microvm Metadata Service) data store.
         * @param {object} [body] The MMDS data store as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMmds(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMmds(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
         * @summary Set MMDS configuration. Pre-boot only.
         * @param {MmdsConfig} body The MMDS configuration as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMmdsConfig(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMmdsConfig(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.DefaultApiFp = DefaultApiFp;
/**
 * DefaultApi - factory interface
 * @export
 */
const DefaultApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DefaultApiFp)(configuration);
    return {
        /**
         * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
         * @summary Creates a full or diff snapshot. Post-boot only.
         * @param {SnapshotCreateParams} body The configuration used for creating a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot(body, options) {
            return localVarFp.createSnapshot(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a synchronous action.
         * @param {InstanceActionInfo} info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSyncAction(info, options) {
            return localVarFp.createSyncAction(info, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the current balloon device configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeBalloonConfig(options) {
            return localVarFp.describeBalloonConfig(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the latest balloon device statistics, only if enabled pre-boot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeBalloonStats(options) {
            return localVarFp.describeBalloonStats(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns general information about an instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeInstance(options) {
            return localVarFp.describeInstance(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
         * @summary Gets the full VM configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportVmConfig(options) {
            return localVarFp.getExportVmConfig(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets the Firecracker version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirecrackerVersion(options) {
            return localVarFp.getFirecrackerVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
         * @summary Gets the machine configuration of the VM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMachineConfiguration(options) {
            return localVarFp.getMachineConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the MMDS data store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmds(options) {
            return localVarFp.getMmds(options).then((request) => request(axios, basePath));
        },
        /**
         * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
         * @summary Loads a snapshot. Pre-boot only.
         * @param {SnapshotLoadParams} body The configuration used for loading a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSnapshot(body, options) {
            return localVarFp.loadSnapshot(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device.
         * @param {BalloonUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBalloon(body, options) {
            return localVarFp.patchBalloon(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device statistics polling interval.
         * @param {BalloonStatsUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBalloonStatsInterval(body, options) {
            return localVarFp.patchBalloonStatsInterval(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
         * @summary Updates the properties of a drive. Post-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {PartialDrive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGuestDriveByID(driveId, body, options) {
            return localVarFp.patchGuestDriveByID(driveId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the rate limiters applied to a network interface.
         * @summary Updates the rate limiters applied to a network interface. Post-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {PartialNetworkInterface} body A subset of the guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGuestNetworkInterfaceByID(ifaceId, body, options) {
            return localVarFp.patchGuestNetworkInterfaceByID(ifaceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
         * @summary Partially updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] A subset of Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMachineConfiguration(body, options) {
            return localVarFp.patchMachineConfiguration(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates the MMDS data store.
         * @param {object} [body] The MMDS data store patch JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMmds(body, options) {
            return localVarFp.patchMmds(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the desired state (Paused or Resumed) for the microVM.
         * @summary Updates the microVM state.
         * @param {Vm} body The microVM state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVm(body, options) {
            return localVarFp.patchVm(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
         * @summary Creates or updates a balloon device.
         * @param {Balloon} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBalloon(body, options) {
            return localVarFp.putBalloon(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
         * @summary Creates or updates the boot source. Pre-boot only.
         * @param {BootSource} body Guest boot source properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestBootSource(body, options) {
            return localVarFp.putGuestBootSource(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
         * @summary Creates or updates a drive. Pre-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {Drive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestDriveByID(driveId, body, options) {
            return localVarFp.putGuestDriveByID(driveId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new network interface with ID specified by iface_id path parameter.
         * @summary Creates a network interface. Pre-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {NetworkInterface} body Guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestNetworkInterfaceByID(ifaceId, body, options) {
            return localVarFp.putGuestNetworkInterfaceByID(ifaceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
         * @summary Creates/updates a vsock device. Pre-boot only.
         * @param {Vsock} body Guest vsock properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestVsock(body, options) {
            return localVarFp.putGuestVsock(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Initializes the logger by specifying a named pipe or a file for the logs output.
         * @param {Logger} body Logging system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLogger(body, options) {
            return localVarFp.putLogger(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
         * @summary Updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMachineConfiguration(body, options) {
            return localVarFp.putMachineConfiguration(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Initializes the metrics system by specifying a named pipe or a file for the metrics output.
         * @param {Metrics} body Metrics system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMetrics(body, options) {
            return localVarFp.putMetrics(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a MMDS (Microvm Metadata Service) data store.
         * @param {object} [body] The MMDS data store as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMmds(body, options) {
            return localVarFp.putMmds(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
         * @summary Set MMDS configuration. Pre-boot only.
         * @param {MmdsConfig} body The MMDS configuration as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMmdsConfig(body, options) {
            return localVarFp.putMmdsConfig(body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DefaultApiFactory = DefaultApiFactory;
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
class DefaultApi extends base_1.BaseAPI {
    /**
     * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
     * @summary Creates a full or diff snapshot. Post-boot only.
     * @param {SnapshotCreateParams} body The configuration used for creating a snaphot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createSnapshot(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).createSnapshot(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a synchronous action.
     * @param {InstanceActionInfo} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createSyncAction(info, options) {
        return (0, exports.DefaultApiFp)(this.configuration).createSyncAction(info, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the current balloon device configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    describeBalloonConfig(options) {
        return (0, exports.DefaultApiFp)(this.configuration).describeBalloonConfig(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the latest balloon device statistics, only if enabled pre-boot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    describeBalloonStats(options) {
        return (0, exports.DefaultApiFp)(this.configuration).describeBalloonStats(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns general information about an instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    describeInstance(options) {
        return (0, exports.DefaultApiFp)(this.configuration).describeInstance(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
     * @summary Gets the full VM configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getExportVmConfig(options) {
        return (0, exports.DefaultApiFp)(this.configuration).getExportVmConfig(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets the Firecracker version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getFirecrackerVersion(options) {
        return (0, exports.DefaultApiFp)(this.configuration).getFirecrackerVersion(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
     * @summary Gets the machine configuration of the VM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getMachineConfiguration(options) {
        return (0, exports.DefaultApiFp)(this.configuration).getMachineConfiguration(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the MMDS data store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getMmds(options) {
        return (0, exports.DefaultApiFp)(this.configuration).getMmds(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
     * @summary Loads a snapshot. Pre-boot only.
     * @param {SnapshotLoadParams} body The configuration used for loading a snaphot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    loadSnapshot(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).loadSnapshot(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
     * @summary Updates a balloon device.
     * @param {BalloonUpdate} body Balloon properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    patchBalloon(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).patchBalloon(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
     * @summary Updates a balloon device statistics polling interval.
     * @param {BalloonStatsUpdate} body Balloon properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    patchBalloonStatsInterval(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).patchBalloonStatsInterval(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
     * @summary Updates the properties of a drive. Post-boot only.
     * @param {string} driveId The id of the guest drive
     * @param {PartialDrive} body Guest drive properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    patchGuestDriveByID(driveId, body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).patchGuestDriveByID(driveId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the rate limiters applied to a network interface.
     * @summary Updates the rate limiters applied to a network interface. Post-boot only.
     * @param {string} ifaceId The id of the guest network interface
     * @param {PartialNetworkInterface} body A subset of the guest network interface properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    patchGuestNetworkInterfaceByID(ifaceId, body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).patchGuestNetworkInterfaceByID(ifaceId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
     * @summary Partially updates the Machine Configuration of the VM. Pre-boot only.
     * @param {MachineConfiguration} [body] A subset of Machine Configuration Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    patchMachineConfiguration(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).patchMachineConfiguration(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates the MMDS data store.
     * @param {object} [body] The MMDS data store patch JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    patchMmds(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).patchMmds(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the desired state (Paused or Resumed) for the microVM.
     * @summary Updates the microVM state.
     * @param {Vm} body The microVM state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    patchVm(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).patchVm(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
     * @summary Creates or updates a balloon device.
     * @param {Balloon} body Balloon properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putBalloon(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putBalloon(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
     * @summary Creates or updates the boot source. Pre-boot only.
     * @param {BootSource} body Guest boot source properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putGuestBootSource(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putGuestBootSource(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
     * @summary Creates or updates a drive. Pre-boot only.
     * @param {string} driveId The id of the guest drive
     * @param {Drive} body Guest drive properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putGuestDriveByID(driveId, body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putGuestDriveByID(driveId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates new network interface with ID specified by iface_id path parameter.
     * @summary Creates a network interface. Pre-boot only.
     * @param {string} ifaceId The id of the guest network interface
     * @param {NetworkInterface} body Guest network interface properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putGuestNetworkInterfaceByID(ifaceId, body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putGuestNetworkInterfaceByID(ifaceId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
     * @summary Creates/updates a vsock device. Pre-boot only.
     * @param {Vsock} body Guest vsock properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putGuestVsock(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putGuestVsock(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Initializes the logger by specifying a named pipe or a file for the logs output.
     * @param {Logger} body Logging system description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putLogger(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putLogger(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
     * @summary Updates the Machine Configuration of the VM. Pre-boot only.
     * @param {MachineConfiguration} [body] Machine Configuration Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putMachineConfiguration(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putMachineConfiguration(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Initializes the metrics system by specifying a named pipe or a file for the metrics output.
     * @param {Metrics} body Metrics system description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putMetrics(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putMetrics(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a MMDS (Microvm Metadata Service) data store.
     * @param {object} [body] The MMDS data store as JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putMmds(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putMmds(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
     * @summary Set MMDS configuration. Pre-boot only.
     * @param {MmdsConfig} body The MMDS configuration as JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    putMmdsConfig(body, options) {
        return (0, exports.DefaultApiFp)(this.configuration).putMmdsConfig(body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DefaultApi = DefaultApi;
