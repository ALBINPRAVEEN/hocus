/* tslint:disable */
/* eslint-disable */
/**
 * Firecracker API
 * RESTful public-facing API. The API is accessible through HTTP calls on specific URLs carrying JSON modeled data. The transport medium is a Unix Domain Socket.
 *
 * The version of the OpenAPI document: 1.1.2
 * Contact: compute-capsule@amazon.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Balloon,
  BalloonStats,
  BalloonStatsUpdate,
  BalloonUpdate,
  BootSource,
  Drive,
  FirecrackerVersion,
  FullVmConfiguration,
  InstanceActionInfo,
  InstanceInfo,
  Logger,
  MachineConfiguration,
  Metrics,
  MmdsConfig,
  NetworkInterface,
  PartialDrive,
  PartialNetworkInterface,
  SnapshotCreateParams,
  SnapshotLoadParams,
  Vm,
  Vsock,
} from '../models';
import {
    BalloonFromJSON,
    BalloonToJSON,
    BalloonStatsFromJSON,
    BalloonStatsToJSON,
    BalloonStatsUpdateFromJSON,
    BalloonStatsUpdateToJSON,
    BalloonUpdateFromJSON,
    BalloonUpdateToJSON,
    BootSourceFromJSON,
    BootSourceToJSON,
    DriveFromJSON,
    DriveToJSON,
    FirecrackerVersionFromJSON,
    FirecrackerVersionToJSON,
    FullVmConfigurationFromJSON,
    FullVmConfigurationToJSON,
    InstanceActionInfoFromJSON,
    InstanceActionInfoToJSON,
    InstanceInfoFromJSON,
    InstanceInfoToJSON,
    LoggerFromJSON,
    LoggerToJSON,
    MachineConfigurationFromJSON,
    MachineConfigurationToJSON,
    MetricsFromJSON,
    MetricsToJSON,
    MmdsConfigFromJSON,
    MmdsConfigToJSON,
    NetworkInterfaceFromJSON,
    NetworkInterfaceToJSON,
    PartialDriveFromJSON,
    PartialDriveToJSON,
    PartialNetworkInterfaceFromJSON,
    PartialNetworkInterfaceToJSON,
    SnapshotCreateParamsFromJSON,
    SnapshotCreateParamsToJSON,
    SnapshotLoadParamsFromJSON,
    SnapshotLoadParamsToJSON,
    VmFromJSON,
    VmToJSON,
    VsockFromJSON,
    VsockToJSON,
} from '../models';

export interface CreateSnapshotRequest {
    body: SnapshotCreateParams;
}

export interface CreateSyncActionRequest {
    info: InstanceActionInfo;
}

export interface LoadSnapshotRequest {
    body: SnapshotLoadParams;
}

export interface PatchBalloonRequest {
    body: BalloonUpdate;
}

export interface PatchBalloonStatsIntervalRequest {
    body: BalloonStatsUpdate;
}

export interface PatchGuestDriveByIDRequest {
    driveId: string;
    body: PartialDrive;
}

export interface PatchGuestNetworkInterfaceByIDRequest {
    ifaceId: string;
    body: PartialNetworkInterface;
}

export interface PatchMachineConfigurationRequest {
    body?: MachineConfiguration;
}

export interface PatchMmdsRequest {
    body?: object;
}

export interface PatchVmRequest {
    body: Vm;
}

export interface PutBalloonRequest {
    body: Balloon;
}

export interface PutGuestBootSourceRequest {
    body: BootSource;
}

export interface PutGuestDriveByIDRequest {
    driveId: string;
    body: Drive;
}

export interface PutGuestNetworkInterfaceByIDRequest {
    ifaceId: string;
    body: NetworkInterface;
}

export interface PutGuestVsockRequest {
    body: Vsock;
}

export interface PutLoggerRequest {
    body: Logger;
}

export interface PutMachineConfigurationRequest {
    body?: MachineConfiguration;
}

export interface PutMetricsRequest {
    body: Metrics;
}

export interface PutMmdsRequest {
    body?: object;
}

export interface PutMmdsConfigRequest {
    body: MmdsConfig;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
     * Creates a full or diff snapshot. Post-boot only.
     */
    async createSnapshotRaw(requestParameters: CreateSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createSnapshot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/snapshot/create`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SnapshotCreateParamsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
     * Creates a full or diff snapshot. Post-boot only.
     */
    async createSnapshot(requestParameters: CreateSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createSnapshotRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a synchronous action.
     */
    async createSyncActionRaw(requestParameters: CreateSyncActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.info === null || requestParameters.info === undefined) {
            throw new runtime.RequiredError('info','Required parameter requestParameters.info was null or undefined when calling createSyncAction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/actions`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InstanceActionInfoToJSON(requestParameters.info),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a synchronous action.
     */
    async createSyncAction(requestParameters: CreateSyncActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createSyncActionRaw(requestParameters, initOverrides);
    }

    /**
     * Returns the current balloon device configuration.
     */
    async describeBalloonConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Balloon>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/balloon`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BalloonFromJSON(jsonValue));
    }

    /**
     * Returns the current balloon device configuration.
     */
    async describeBalloonConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Balloon> {
        const response = await this.describeBalloonConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the latest balloon device statistics, only if enabled pre-boot.
     */
    async describeBalloonStatsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BalloonStats>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/balloon/statistics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BalloonStatsFromJSON(jsonValue));
    }

    /**
     * Returns the latest balloon device statistics, only if enabled pre-boot.
     */
    async describeBalloonStats(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BalloonStats> {
        const response = await this.describeBalloonStatsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns general information about an instance.
     */
    async describeInstanceRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InstanceInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InstanceInfoFromJSON(jsonValue));
    }

    /**
     * Returns general information about an instance.
     */
    async describeInstance(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InstanceInfo> {
        const response = await this.describeInstanceRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
     * Gets the full VM configuration.
     */
    async getExportVmConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullVmConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/vm/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullVmConfigurationFromJSON(jsonValue));
    }

    /**
     * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
     * Gets the full VM configuration.
     */
    async getExportVmConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullVmConfiguration> {
        const response = await this.getExportVmConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the Firecracker version.
     */
    async getFirecrackerVersionRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FirecrackerVersion>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FirecrackerVersionFromJSON(jsonValue));
    }

    /**
     * Gets the Firecracker version.
     */
    async getFirecrackerVersion(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FirecrackerVersion> {
        const response = await this.getFirecrackerVersionRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
     * Gets the machine configuration of the VM.
     */
    async getMachineConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MachineConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/machine-config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MachineConfigurationFromJSON(jsonValue));
    }

    /**
     * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
     * Gets the machine configuration of the VM.
     */
    async getMachineConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MachineConfiguration> {
        const response = await this.getMachineConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the MMDS data store.
     */
    async getMmdsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mmds`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get the MMDS data store.
     */
    async getMmds(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getMmdsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
     * Loads a snapshot. Pre-boot only.
     */
    async loadSnapshotRaw(requestParameters: LoadSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling loadSnapshot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/snapshot/load`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SnapshotLoadParamsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
     * Loads a snapshot. Pre-boot only.
     */
    async loadSnapshot(requestParameters: LoadSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.loadSnapshotRaw(requestParameters, initOverrides);
    }

    /**
     * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
     * Updates a balloon device.
     */
    async patchBalloonRaw(requestParameters: PatchBalloonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchBalloon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/balloon`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: BalloonUpdateToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
     * Updates a balloon device.
     */
    async patchBalloon(requestParameters: PatchBalloonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchBalloonRaw(requestParameters, initOverrides);
    }

    /**
     * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
     * Updates a balloon device statistics polling interval.
     */
    async patchBalloonStatsIntervalRaw(requestParameters: PatchBalloonStatsIntervalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchBalloonStatsInterval.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/balloon/statistics`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: BalloonStatsUpdateToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
     * Updates a balloon device statistics polling interval.
     */
    async patchBalloonStatsInterval(requestParameters: PatchBalloonStatsIntervalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchBalloonStatsIntervalRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
     * Updates the properties of a drive. Post-boot only.
     */
    async patchGuestDriveByIDRaw(requestParameters: PatchGuestDriveByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.driveId === null || requestParameters.driveId === undefined) {
            throw new runtime.RequiredError('driveId','Required parameter requestParameters.driveId was null or undefined when calling patchGuestDriveByID.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchGuestDriveByID.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/drives/{drive_id}`.replace(`{${"drive_id"}}`, encodeURIComponent(String(requestParameters.driveId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PartialDriveToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
     * Updates the properties of a drive. Post-boot only.
     */
    async patchGuestDriveByID(requestParameters: PatchGuestDriveByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchGuestDriveByIDRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the rate limiters applied to a network interface.
     * Updates the rate limiters applied to a network interface. Post-boot only.
     */
    async patchGuestNetworkInterfaceByIDRaw(requestParameters: PatchGuestNetworkInterfaceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.ifaceId === null || requestParameters.ifaceId === undefined) {
            throw new runtime.RequiredError('ifaceId','Required parameter requestParameters.ifaceId was null or undefined when calling patchGuestNetworkInterfaceByID.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchGuestNetworkInterfaceByID.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/network-interfaces/{iface_id}`.replace(`{${"iface_id"}}`, encodeURIComponent(String(requestParameters.ifaceId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PartialNetworkInterfaceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the rate limiters applied to a network interface.
     * Updates the rate limiters applied to a network interface. Post-boot only.
     */
    async patchGuestNetworkInterfaceByID(requestParameters: PatchGuestNetworkInterfaceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchGuestNetworkInterfaceByIDRaw(requestParameters, initOverrides);
    }

    /**
     * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
     * Partially updates the Machine Configuration of the VM. Pre-boot only.
     */
    async patchMachineConfigurationRaw(requestParameters: PatchMachineConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/machine-config`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: MachineConfigurationToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
     * Partially updates the Machine Configuration of the VM. Pre-boot only.
     */
    async patchMachineConfiguration(requestParameters: PatchMachineConfigurationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchMachineConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the MMDS data store.
     */
    async patchMmdsRaw(requestParameters: PatchMmdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mmds`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the MMDS data store.
     */
    async patchMmds(requestParameters: PatchMmdsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchMmdsRaw(requestParameters, initOverrides);
    }

    /**
     * Sets the desired state (Paused or Resumed) for the microVM.
     * Updates the microVM state.
     */
    async patchVmRaw(requestParameters: PatchVmRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchVm.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vm`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VmToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Sets the desired state (Paused or Resumed) for the microVM.
     * Updates the microVM state.
     */
    async patchVm(requestParameters: PatchVmRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchVmRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
     * Creates or updates a balloon device.
     */
    async putBalloonRaw(requestParameters: PutBalloonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putBalloon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/balloon`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BalloonToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
     * Creates or updates a balloon device.
     */
    async putBalloon(requestParameters: PutBalloonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putBalloonRaw(requestParameters, initOverrides);
    }

    /**
     * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
     * Creates or updates the boot source. Pre-boot only.
     */
    async putGuestBootSourceRaw(requestParameters: PutGuestBootSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putGuestBootSource.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/boot-source`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BootSourceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
     * Creates or updates the boot source. Pre-boot only.
     */
    async putGuestBootSource(requestParameters: PutGuestBootSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putGuestBootSourceRaw(requestParameters, initOverrides);
    }

    /**
     * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
     * Creates or updates a drive. Pre-boot only.
     */
    async putGuestDriveByIDRaw(requestParameters: PutGuestDriveByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.driveId === null || requestParameters.driveId === undefined) {
            throw new runtime.RequiredError('driveId','Required parameter requestParameters.driveId was null or undefined when calling putGuestDriveByID.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putGuestDriveByID.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/drives/{drive_id}`.replace(`{${"drive_id"}}`, encodeURIComponent(String(requestParameters.driveId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DriveToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
     * Creates or updates a drive. Pre-boot only.
     */
    async putGuestDriveByID(requestParameters: PutGuestDriveByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putGuestDriveByIDRaw(requestParameters, initOverrides);
    }

    /**
     * Creates new network interface with ID specified by iface_id path parameter.
     * Creates a network interface. Pre-boot only.
     */
    async putGuestNetworkInterfaceByIDRaw(requestParameters: PutGuestNetworkInterfaceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.ifaceId === null || requestParameters.ifaceId === undefined) {
            throw new runtime.RequiredError('ifaceId','Required parameter requestParameters.ifaceId was null or undefined when calling putGuestNetworkInterfaceByID.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putGuestNetworkInterfaceByID.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/network-interfaces/{iface_id}`.replace(`{${"iface_id"}}`, encodeURIComponent(String(requestParameters.ifaceId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: NetworkInterfaceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates new network interface with ID specified by iface_id path parameter.
     * Creates a network interface. Pre-boot only.
     */
    async putGuestNetworkInterfaceByID(requestParameters: PutGuestNetworkInterfaceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putGuestNetworkInterfaceByIDRaw(requestParameters, initOverrides);
    }

    /**
     * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
     * Creates/updates a vsock device. Pre-boot only.
     */
    async putGuestVsockRaw(requestParameters: PutGuestVsockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putGuestVsock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vsock`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: VsockToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
     * Creates/updates a vsock device. Pre-boot only.
     */
    async putGuestVsock(requestParameters: PutGuestVsockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putGuestVsockRaw(requestParameters, initOverrides);
    }

    /**
     * Initializes the logger by specifying a named pipe or a file for the logs output.
     */
    async putLoggerRaw(requestParameters: PutLoggerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putLogger.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/logger`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: LoggerToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Initializes the logger by specifying a named pipe or a file for the logs output.
     */
    async putLogger(requestParameters: PutLoggerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putLoggerRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
     * Updates the Machine Configuration of the VM. Pre-boot only.
     */
    async putMachineConfigurationRaw(requestParameters: PutMachineConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/machine-config`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MachineConfigurationToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
     * Updates the Machine Configuration of the VM. Pre-boot only.
     */
    async putMachineConfiguration(requestParameters: PutMachineConfigurationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putMachineConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     * Initializes the metrics system by specifying a named pipe or a file for the metrics output.
     */
    async putMetricsRaw(requestParameters: PutMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putMetrics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/metrics`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MetricsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Initializes the metrics system by specifying a named pipe or a file for the metrics output.
     */
    async putMetrics(requestParameters: PutMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putMetricsRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a MMDS (Microvm Metadata Service) data store.
     */
    async putMmdsRaw(requestParameters: PutMmdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mmds`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a MMDS (Microvm Metadata Service) data store.
     */
    async putMmds(requestParameters: PutMmdsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putMmdsRaw(requestParameters, initOverrides);
    }

    /**
     * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
     * Set MMDS configuration. Pre-boot only.
     */
    async putMmdsConfigRaw(requestParameters: PutMmdsConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putMmdsConfig.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mmds/config`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MmdsConfigToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
     * Set MMDS configuration. Pre-boot only.
     */
    async putMmdsConfig(requestParameters: PutMmdsConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putMmdsConfigRaw(requestParameters, initOverrides);
    }

}
