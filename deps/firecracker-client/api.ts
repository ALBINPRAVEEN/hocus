/* tslint:disable */
/* eslint-disable */
/**
 * Firecracker API
 * RESTful public-facing API. The API is accessible through HTTP calls on specific URLs carrying JSON modeled data. The transport medium is a Unix Domain Socket.
 *
 * The version of the OpenAPI document: 1.1.2
 * Contact: compute-capsule@amazon.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Balloon device descriptor.
 * @export
 * @interface Balloon
 */
export interface Balloon {
    /**
     * Target balloon size in MiB.
     * @type {number}
     * @memberof Balloon
     */
    'amount_mib': number;
    /**
     * Whether the balloon should deflate when the guest has memory pressure.
     * @type {boolean}
     * @memberof Balloon
     */
    'deflate_on_oom': boolean;
    /**
     * Interval in seconds between refreshing statistics. A non-zero value will enable the statistics. Defaults to 0.
     * @type {number}
     * @memberof Balloon
     */
    'stats_polling_interval_s'?: number;
}
/**
 * Describes the balloon device statistics.
 * @export
 * @interface BalloonStats
 */
export interface BalloonStats {
    /**
     * Target number of pages the device aims to hold.
     * @type {number}
     * @memberof BalloonStats
     */
    'target_pages': number;
    /**
     * Actual number of pages the device is holding.
     * @type {number}
     * @memberof BalloonStats
     */
    'actual_pages': number;
    /**
     * Target amount of memory (in MiB) the device aims to hold.
     * @type {number}
     * @memberof BalloonStats
     */
    'target_mib': number;
    /**
     * Actual amount of memory (in MiB) the device is holding.
     * @type {number}
     * @memberof BalloonStats
     */
    'actual_mib': number;
    /**
     * The amount of memory that has been swapped in (in bytes).
     * @type {number}
     * @memberof BalloonStats
     */
    'swap_in'?: number;
    /**
     * The amount of memory that has been swapped out to disk (in bytes).
     * @type {number}
     * @memberof BalloonStats
     */
    'swap_out'?: number;
    /**
     * The number of major page faults that have occurred.
     * @type {number}
     * @memberof BalloonStats
     */
    'major_faults'?: number;
    /**
     * The number of minor page faults that have occurred.
     * @type {number}
     * @memberof BalloonStats
     */
    'minor_faults'?: number;
    /**
     * The amount of memory not being used for any purpose (in bytes).
     * @type {number}
     * @memberof BalloonStats
     */
    'free_memory'?: number;
    /**
     * The total amount of memory available (in bytes).
     * @type {number}
     * @memberof BalloonStats
     */
    'total_memory'?: number;
    /**
     * An estimate of how much memory is available (in bytes) for starting new applications, without pushing the system to swap.
     * @type {number}
     * @memberof BalloonStats
     */
    'available_memory'?: number;
    /**
     * The amount of memory, in bytes, that can be quickly reclaimed without additional I/O. Typically these pages are used for caching files from disk.
     * @type {number}
     * @memberof BalloonStats
     */
    'disk_caches'?: number;
    /**
     * The number of successful hugetlb page allocations in the guest.
     * @type {number}
     * @memberof BalloonStats
     */
    'hugetlb_allocations'?: number;
    /**
     * The number of failed hugetlb page allocations in the guest.
     * @type {number}
     * @memberof BalloonStats
     */
    'hugetlb_failures'?: number;
}
/**
 * Update the statistics polling interval, with the first statistics update scheduled immediately. Statistics cannot be turned on/off after boot.
 * @export
 * @interface BalloonStatsUpdate
 */
export interface BalloonStatsUpdate {
    /**
     * Interval in seconds between refreshing statistics.
     * @type {number}
     * @memberof BalloonStatsUpdate
     */
    'stats_polling_interval_s': number;
}
/**
 * Balloon device descriptor.
 * @export
 * @interface BalloonUpdate
 */
export interface BalloonUpdate {
    /**
     * Target balloon size in MiB.
     * @type {number}
     * @memberof BalloonUpdate
     */
    'amount_mib': number;
}
/**
 * Boot source descriptor.
 * @export
 * @interface BootSource
 */
export interface BootSource {
    /**
     * Kernel boot arguments
     * @type {string}
     * @memberof BootSource
     */
    'boot_args'?: string;
    /**
     * Host level path to the initrd image used to boot the guest
     * @type {string}
     * @memberof BootSource
     */
    'initrd_path'?: string;
    /**
     * Host level path to the kernel image used to boot the guest
     * @type {string}
     * @memberof BootSource
     */
    'kernel_image_path': string;
}
/**
 * The CPU Template defines a set of flags to be disabled from the microvm so that the features exposed to the guest are the same as in the selected instance type. Works only on Intel.
 * @export
 * @enum {string}
 */

export const CpuTemplate = {
    C3: 'C3',
    T2: 'T2',
    T2S: 'T2S',
    None: 'None'
} as const;

export type CpuTemplate = typeof CpuTemplate[keyof typeof CpuTemplate];


/**
 * 
 * @export
 * @interface Drive
 */
export interface Drive {
    /**
     * 
     * @type {string}
     * @memberof Drive
     */
    'drive_id': string;
    /**
     * Represents the caching strategy for the block device.
     * @type {string}
     * @memberof Drive
     */
    'cache_type'?: DriveCacheTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Drive
     */
    'is_read_only': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Drive
     */
    'is_root_device': boolean;
    /**
     * Represents the unique id of the boot partition of this device. It is optional and it will be taken into account only if the is_root_device field is true.
     * @type {string}
     * @memberof Drive
     */
    'partuuid'?: string;
    /**
     * Host level path for the guest drive
     * @type {string}
     * @memberof Drive
     */
    'path_on_host': string;
    /**
     * 
     * @type {RateLimiter}
     * @memberof Drive
     */
    'rate_limiter'?: RateLimiter;
    /**
     * Type of the IO engine used by the device. \"Async\" is supported on host kernels newer than 5.10.51.
     * @type {string}
     * @memberof Drive
     */
    'io_engine'?: DriveIoEngineEnum;
}

export const DriveCacheTypeEnum = {
    Unsafe: 'Unsafe',
    Writeback: 'Writeback'
} as const;

export type DriveCacheTypeEnum = typeof DriveCacheTypeEnum[keyof typeof DriveCacheTypeEnum];
export const DriveIoEngineEnum = {
    Sync: 'Sync',
    Async: 'Async'
} as const;

export type DriveIoEngineEnum = typeof DriveIoEngineEnum[keyof typeof DriveIoEngineEnum];

/**
 * Describes the Firecracker version.
 * @export
 * @interface FirecrackerVersion
 */
export interface FirecrackerVersion {
    /**
     * Firecracker build version.
     * @type {string}
     * @memberof FirecrackerVersion
     */
    'firecracker_version': string;
}
/**
 * 
 * @export
 * @interface FullVmConfiguration
 */
export interface FullVmConfiguration {
    /**
     * 
     * @type {Balloon}
     * @memberof FullVmConfiguration
     */
    'balloon'?: Balloon;
    /**
     * Configurations for all block devices.
     * @type {Array<Drive>}
     * @memberof FullVmConfiguration
     */
    'drives'?: Array<Drive>;
    /**
     * 
     * @type {BootSource}
     * @memberof FullVmConfiguration
     */
    'boot-source'?: BootSource;
    /**
     * 
     * @type {Logger}
     * @memberof FullVmConfiguration
     */
    'logger'?: Logger;
    /**
     * 
     * @type {MachineConfiguration}
     * @memberof FullVmConfiguration
     */
    'machine-config'?: MachineConfiguration;
    /**
     * 
     * @type {Metrics}
     * @memberof FullVmConfiguration
     */
    'metrics'?: Metrics;
    /**
     * 
     * @type {MmdsConfig}
     * @memberof FullVmConfiguration
     */
    'mmds-config'?: MmdsConfig;
    /**
     * Configurations for all net devices.
     * @type {Array<NetworkInterface>}
     * @memberof FullVmConfiguration
     */
    'network-interfaces'?: Array<NetworkInterface>;
    /**
     * 
     * @type {Vsock}
     * @memberof FullVmConfiguration
     */
    'vsock'?: Vsock;
}
/**
 * Variant wrapper containing the real action.
 * @export
 * @interface InstanceActionInfo
 */
export interface InstanceActionInfo {
    /**
     * Enumeration indicating what type of action is contained in the payload
     * @type {string}
     * @memberof InstanceActionInfo
     */
    'action_type': InstanceActionInfoActionTypeEnum;
}

export const InstanceActionInfoActionTypeEnum = {
    FlushMetrics: 'FlushMetrics',
    InstanceStart: 'InstanceStart',
    SendCtrlAltDel: 'SendCtrlAltDel'
} as const;

export type InstanceActionInfoActionTypeEnum = typeof InstanceActionInfoActionTypeEnum[keyof typeof InstanceActionInfoActionTypeEnum];

/**
 * Describes MicroVM instance information.
 * @export
 * @interface InstanceInfo
 */
export interface InstanceInfo {
    /**
     * Application name.
     * @type {string}
     * @memberof InstanceInfo
     */
    'app_name': string;
    /**
     * MicroVM / instance ID.
     * @type {string}
     * @memberof InstanceInfo
     */
    'id': string;
    /**
     * The current detailed state (Not started, Running, Paused) of the Firecracker instance. This value is read-only for the control-plane.
     * @type {string}
     * @memberof InstanceInfo
     */
    'state': InstanceInfoStateEnum;
    /**
     * MicroVM hypervisor build version.
     * @type {string}
     * @memberof InstanceInfo
     */
    'vmm_version': string;
}

export const InstanceInfoStateEnum = {
    NotStarted: 'Not started',
    Running: 'Running',
    Paused: 'Paused'
} as const;

export type InstanceInfoStateEnum = typeof InstanceInfoStateEnum[keyof typeof InstanceInfoStateEnum];

/**
 * Describes the configuration option for the logging capability.
 * @export
 * @interface Logger
 */
export interface Logger {
    /**
     * Set the level. The possible values are case-insensitive.
     * @type {string}
     * @memberof Logger
     */
    'level'?: LoggerLevelEnum;
    /**
     * Path to the named pipe or file for the human readable log output.
     * @type {string}
     * @memberof Logger
     */
    'log_path': string;
    /**
     * Whether or not to output the level in the logs.
     * @type {boolean}
     * @memberof Logger
     */
    'show_level'?: boolean;
    /**
     * Whether or not to include the file path and line number of the log\'s origin.
     * @type {boolean}
     * @memberof Logger
     */
    'show_log_origin'?: boolean;
}

export const LoggerLevelEnum = {
    Error: 'Error',
    Warning: 'Warning',
    Info: 'Info',
    Debug: 'Debug'
} as const;

export type LoggerLevelEnum = typeof LoggerLevelEnum[keyof typeof LoggerLevelEnum];

/**
 * Describes the number of vCPUs, memory size, SMT capabilities and the CPU template.
 * @export
 * @interface MachineConfiguration
 */
export interface MachineConfiguration {
    /**
     * 
     * @type {CpuTemplate}
     * @memberof MachineConfiguration
     */
    'cpu_template'?: CpuTemplate;
    /**
     * Flag for enabling/disabling simultaneous multithreading. Can be enabled only on x86.
     * @type {boolean}
     * @memberof MachineConfiguration
     */
    'smt'?: boolean;
    /**
     * Memory size of VM
     * @type {number}
     * @memberof MachineConfiguration
     */
    'mem_size_mib': number;
    /**
     * Enable dirty page tracking. If this is enabled, then incremental guest memory snapshots can be created. These belong to diff snapshots, which contain, besides the microVM state, only the memory dirtied since a previous snapshot. Full snapshots each contain a full copy of the guest memory.
     * @type {boolean}
     * @memberof MachineConfiguration
     */
    'track_dirty_pages'?: boolean;
    /**
     * Number of vCPUs (either 1 or an even number)
     * @type {number}
     * @memberof MachineConfiguration
     */
    'vcpu_count': number;
}
/**
 * 
 * @export
 * @interface MemoryBackend
 */
export interface MemoryBackend {
    /**
     * 
     * @type {string}
     * @memberof MemoryBackend
     */
    'backend_type': MemoryBackendBackendTypeEnum;
    /**
     * Based on \'backend_type\' it is either 1) Path to the file that contains the guest memory to be loaded 2) Path to the UDS where a process is listening for a UFFD initialization control payload and open file descriptor that it can use to serve this process\'s guest memory page faults
     * @type {string}
     * @memberof MemoryBackend
     */
    'backend_path': string;
}

export const MemoryBackendBackendTypeEnum = {
    File: 'File',
    Uffd: 'Uffd'
} as const;

export type MemoryBackendBackendTypeEnum = typeof MemoryBackendBackendTypeEnum[keyof typeof MemoryBackendBackendTypeEnum];

/**
 * Describes the configuration option for the metrics capability.
 * @export
 * @interface Metrics
 */
export interface Metrics {
    /**
     * Path to the named pipe or file where the JSON-formatted metrics are flushed.
     * @type {string}
     * @memberof Metrics
     */
    'metrics_path': string;
}
/**
 * Defines the MMDS configuration.
 * @export
 * @interface MmdsConfig
 */
export interface MmdsConfig {
    /**
     * Enumeration indicating the MMDS version to be configured.
     * @type {string}
     * @memberof MmdsConfig
     */
    'version'?: MmdsConfigVersionEnum;
    /**
     * List of the network interface IDs capable of forwarding packets to the MMDS. Network interface IDs mentioned must be valid at the time of this request. The net device model will reply to HTTP GET requests sent to the MMDS address via the interfaces mentioned. In this case, both ARP requests and TCP segments heading to `ipv4_address` are intercepted by the device model, and do not reach the associated TAP device.
     * @type {Array<string>}
     * @memberof MmdsConfig
     */
    'network_interfaces': Array<string>;
    /**
     * A valid IPv4 link-local address.
     * @type {string}
     * @memberof MmdsConfig
     */
    'ipv4_address'?: string;
}

export const MmdsConfigVersionEnum = {
    V1: 'V1',
    V2: 'V2'
} as const;

export type MmdsConfigVersionEnum = typeof MmdsConfigVersionEnum[keyof typeof MmdsConfigVersionEnum];

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A description of the error condition
     * @type {string}
     * @memberof ModelError
     */
    'fault_message'?: string;
}
/**
 * Defines a network interface.
 * @export
 * @interface NetworkInterface
 */
export interface NetworkInterface {
    /**
     * 
     * @type {string}
     * @memberof NetworkInterface
     */
    'guest_mac'?: string;
    /**
     * Host level path for the guest network interface
     * @type {string}
     * @memberof NetworkInterface
     */
    'host_dev_name': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterface
     */
    'iface_id': string;
    /**
     * 
     * @type {RateLimiter}
     * @memberof NetworkInterface
     */
    'rx_rate_limiter'?: RateLimiter;
    /**
     * 
     * @type {RateLimiter}
     * @memberof NetworkInterface
     */
    'tx_rate_limiter'?: RateLimiter;
}
/**
 * 
 * @export
 * @interface PartialDrive
 */
export interface PartialDrive {
    /**
     * 
     * @type {string}
     * @memberof PartialDrive
     */
    'drive_id': string;
    /**
     * Host level path for the guest drive
     * @type {string}
     * @memberof PartialDrive
     */
    'path_on_host'?: string;
    /**
     * 
     * @type {RateLimiter}
     * @memberof PartialDrive
     */
    'rate_limiter'?: RateLimiter;
}
/**
 * Defines a partial network interface structure, used to update the rate limiters for that interface, after microvm start.
 * @export
 * @interface PartialNetworkInterface
 */
export interface PartialNetworkInterface {
    /**
     * 
     * @type {string}
     * @memberof PartialNetworkInterface
     */
    'iface_id': string;
    /**
     * 
     * @type {RateLimiter}
     * @memberof PartialNetworkInterface
     */
    'rx_rate_limiter'?: RateLimiter;
    /**
     * 
     * @type {RateLimiter}
     * @memberof PartialNetworkInterface
     */
    'tx_rate_limiter'?: RateLimiter;
}
/**
 * Defines an IO rate limiter with independent bytes/s and ops/s limits. Limits are defined by configuring each of the _bandwidth_ and _ops_ token buckets.
 * @export
 * @interface RateLimiter
 */
export interface RateLimiter {
    /**
     * 
     * @type {TokenBucket}
     * @memberof RateLimiter
     */
    'bandwidth'?: TokenBucket;
    /**
     * 
     * @type {TokenBucket}
     * @memberof RateLimiter
     */
    'ops'?: TokenBucket;
}
/**
 * 
 * @export
 * @interface SnapshotCreateParams
 */
export interface SnapshotCreateParams {
    /**
     * Path to the file that will contain the guest memory.
     * @type {string}
     * @memberof SnapshotCreateParams
     */
    'mem_file_path': string;
    /**
     * Path to the file that will contain the microVM state.
     * @type {string}
     * @memberof SnapshotCreateParams
     */
    'snapshot_path': string;
    /**
     * Type of snapshot to create. It is optional and by default, a full snapshot is created.
     * @type {string}
     * @memberof SnapshotCreateParams
     */
    'snapshot_type'?: SnapshotCreateParamsSnapshotTypeEnum;
    /**
     * The microVM version for which we want to create the snapshot. It is optional and it defaults to the current version.
     * @type {string}
     * @memberof SnapshotCreateParams
     */
    'version'?: string;
}

export const SnapshotCreateParamsSnapshotTypeEnum = {
    Full: 'Full',
    Diff: 'Diff'
} as const;

export type SnapshotCreateParamsSnapshotTypeEnum = typeof SnapshotCreateParamsSnapshotTypeEnum[keyof typeof SnapshotCreateParamsSnapshotTypeEnum];

/**
 * Defines the configuration used for handling snapshot resume. Exactly one of the two `mem_*` fields must be present in the body of the request.
 * @export
 * @interface SnapshotLoadParams
 */
export interface SnapshotLoadParams {
    /**
     * Enable support for incremental (diff) snapshots by tracking dirty guest pages.
     * @type {boolean}
     * @memberof SnapshotLoadParams
     */
    'enable_diff_snapshots'?: boolean;
    /**
     * Path to the file that contains the guest memory to be loaded. This parameter has been deprecated and is only allowed if `mem_backend` is not present.
     * @type {string}
     * @memberof SnapshotLoadParams
     */
    'mem_file_path'?: string;
    /**
     * 
     * @type {MemoryBackend}
     * @memberof SnapshotLoadParams
     */
    'mem_backend'?: MemoryBackend;
    /**
     * Path to the file that contains the microVM state to be loaded.
     * @type {string}
     * @memberof SnapshotLoadParams
     */
    'snapshot_path': string;
    /**
     * When set to true, the vm is also resumed if the snapshot load is successful.
     * @type {boolean}
     * @memberof SnapshotLoadParams
     */
    'resume_vm'?: boolean;
}
/**
 * Defines a token bucket with a maximum capacity (size), an initial burst size (one_time_burst) and an interval for refilling purposes (refill_time). The refill-rate is derived from size and refill_time, and it is the constant rate at which the tokens replenish. The refill process only starts happening after the initial burst budget is consumed. Consumption from the token bucket is unbounded in speed which allows for bursts bound in size by the amount of tokens available. Once the token bucket is empty, consumption speed is bound by the refill_rate.
 * @export
 * @interface TokenBucket
 */
export interface TokenBucket {
    /**
     * The initial size of a token bucket.
     * @type {number}
     * @memberof TokenBucket
     */
    'one_time_burst'?: number;
    /**
     * The amount of milliseconds it takes for the bucket to refill.
     * @type {number}
     * @memberof TokenBucket
     */
    'refill_time': number;
    /**
     * The total number of tokens this bucket can hold.
     * @type {number}
     * @memberof TokenBucket
     */
    'size': number;
}
/**
 * Defines the microVM running state. It is especially useful in the snapshotting context.
 * @export
 * @interface Vm
 */
export interface Vm {
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    'state': VmStateEnum;
}

export const VmStateEnum = {
    Paused: 'Paused',
    Resumed: 'Resumed'
} as const;

export type VmStateEnum = typeof VmStateEnum[keyof typeof VmStateEnum];

/**
 * Defines a vsock device, backed by a set of Unix Domain Sockets, on the host side. For host-initiated connections, Firecracker will be listening on the Unix socket identified by the path `uds_path`. Firecracker will create this socket, bind and listen on it. Host-initiated connections will be performed by connection to this socket and issuing a connection forwarding request to the desired guest-side vsock port (i.e. `CONNECT 52\\n`, to connect to port 52). For guest-initiated connections, Firecracker will expect host software to be bound and listening on Unix sockets at `uds_path_<PORT>`. E.g. \"/path/to/host_vsock.sock_52\" for port number 52.
 * @export
 * @interface Vsock
 */
export interface Vsock {
    /**
     * Guest Vsock CID
     * @type {number}
     * @memberof Vsock
     */
    'guest_cid': number;
    /**
     * Path to UNIX domain socket, used to proxy vsock connections.
     * @type {string}
     * @memberof Vsock
     */
    'uds_path': string;
    /**
     * This parameter has been deprecated since v1.0.0.
     * @type {string}
     * @memberof Vsock
     */
    'vsock_id'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
         * @summary Creates a full or diff snapshot. Post-boot only.
         * @param {SnapshotCreateParams} body The configuration used for creating a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot: async (body: SnapshotCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSnapshot', 'body', body)
            const localVarPath = `/snapshot/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a synchronous action.
         * @param {InstanceActionInfo} info 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSyncAction: async (info: InstanceActionInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'info' is not null or undefined
            assertParamExists('createSyncAction', 'info', info)
            const localVarPath = `/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(info, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the current balloon device configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeBalloonConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balloon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the latest balloon device statistics, only if enabled pre-boot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeBalloonStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balloon/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns general information about an instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeInstance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
         * @summary Gets the full VM configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportVmConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vm/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the Firecracker version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirecrackerVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
         * @summary Gets the machine configuration of the VM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMachineConfiguration: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/machine-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the MMDS data store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmds: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mmds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
         * @summary Loads a snapshot. Pre-boot only.
         * @param {SnapshotLoadParams} body The configuration used for loading a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSnapshot: async (body: SnapshotLoadParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('loadSnapshot', 'body', body)
            const localVarPath = `/snapshot/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device.
         * @param {BalloonUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBalloon: async (body: BalloonUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchBalloon', 'body', body)
            const localVarPath = `/balloon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device statistics polling interval.
         * @param {BalloonStatsUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBalloonStatsInterval: async (body: BalloonStatsUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchBalloonStatsInterval', 'body', body)
            const localVarPath = `/balloon/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
         * @summary Updates the properties of a drive. Post-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {PartialDrive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGuestDriveByID: async (driveId: string, body: PartialDrive, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('patchGuestDriveByID', 'driveId', driveId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchGuestDriveByID', 'body', body)
            const localVarPath = `/drives/{drive_id}`
                .replace(`{${"drive_id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the rate limiters applied to a network interface.
         * @summary Updates the rate limiters applied to a network interface. Post-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {PartialNetworkInterface} body A subset of the guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGuestNetworkInterfaceByID: async (ifaceId: string, body: PartialNetworkInterface, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ifaceId' is not null or undefined
            assertParamExists('patchGuestNetworkInterfaceByID', 'ifaceId', ifaceId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchGuestNetworkInterfaceByID', 'body', body)
            const localVarPath = `/network-interfaces/{iface_id}`
                .replace(`{${"iface_id"}}`, encodeURIComponent(String(ifaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
         * @summary Partially updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] A subset of Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMachineConfiguration: async (body?: MachineConfiguration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/machine-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the MMDS data store.
         * @param {object} [body] The MMDS data store patch JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMmds: async (body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mmds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the desired state (Paused or Resumed) for the microVM.
         * @summary Updates the microVM state.
         * @param {Vm} body The microVM state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVm: async (body: Vm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchVm', 'body', body)
            const localVarPath = `/vm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
         * @summary Creates or updates a balloon device.
         * @param {Balloon} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBalloon: async (body: Balloon, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putBalloon', 'body', body)
            const localVarPath = `/balloon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
         * @summary Creates or updates the boot source. Pre-boot only.
         * @param {BootSource} body Guest boot source properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestBootSource: async (body: BootSource, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putGuestBootSource', 'body', body)
            const localVarPath = `/boot-source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
         * @summary Creates or updates a drive. Pre-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {Drive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestDriveByID: async (driveId: string, body: Drive, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('putGuestDriveByID', 'driveId', driveId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putGuestDriveByID', 'body', body)
            const localVarPath = `/drives/{drive_id}`
                .replace(`{${"drive_id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new network interface with ID specified by iface_id path parameter.
         * @summary Creates a network interface. Pre-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {NetworkInterface} body Guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestNetworkInterfaceByID: async (ifaceId: string, body: NetworkInterface, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ifaceId' is not null or undefined
            assertParamExists('putGuestNetworkInterfaceByID', 'ifaceId', ifaceId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putGuestNetworkInterfaceByID', 'body', body)
            const localVarPath = `/network-interfaces/{iface_id}`
                .replace(`{${"iface_id"}}`, encodeURIComponent(String(ifaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
         * @summary Creates/updates a vsock device. Pre-boot only.
         * @param {Vsock} body Guest vsock properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestVsock: async (body: Vsock, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putGuestVsock', 'body', body)
            const localVarPath = `/vsock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initializes the logger by specifying a named pipe or a file for the logs output.
         * @param {Logger} body Logging system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLogger: async (body: Logger, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putLogger', 'body', body)
            const localVarPath = `/logger`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
         * @summary Updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMachineConfiguration: async (body?: MachineConfiguration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/machine-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initializes the metrics system by specifying a named pipe or a file for the metrics output.
         * @param {Metrics} body Metrics system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMetrics: async (body: Metrics, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putMetrics', 'body', body)
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a MMDS (Microvm Metadata Service) data store.
         * @param {object} [body] The MMDS data store as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMmds: async (body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mmds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
         * @summary Set MMDS configuration. Pre-boot only.
         * @param {MmdsConfig} body The MMDS configuration as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMmdsConfig: async (body: MmdsConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putMmdsConfig', 'body', body)
            const localVarPath = `/mmds/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
         * @summary Creates a full or diff snapshot. Post-boot only.
         * @param {SnapshotCreateParams} body The configuration used for creating a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSnapshot(body: SnapshotCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSnapshot(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a synchronous action.
         * @param {InstanceActionInfo} info 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSyncAction(info: InstanceActionInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSyncAction(info, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the current balloon device configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeBalloonConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balloon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeBalloonConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the latest balloon device statistics, only if enabled pre-boot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeBalloonStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalloonStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeBalloonStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns general information about an instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeInstance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeInstance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
         * @summary Gets the full VM configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportVmConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullVmConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportVmConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the Firecracker version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirecrackerVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirecrackerVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirecrackerVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
         * @summary Gets the machine configuration of the VM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMachineConfiguration(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachineConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMachineConfiguration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the MMDS data store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmds(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmds(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
         * @summary Loads a snapshot. Pre-boot only.
         * @param {SnapshotLoadParams} body The configuration used for loading a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadSnapshot(body: SnapshotLoadParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadSnapshot(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device.
         * @param {BalloonUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBalloon(body: BalloonUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchBalloon(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device statistics polling interval.
         * @param {BalloonStatsUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBalloonStatsInterval(body: BalloonStatsUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchBalloonStatsInterval(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
         * @summary Updates the properties of a drive. Post-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {PartialDrive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGuestDriveByID(driveId: string, body: PartialDrive, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGuestDriveByID(driveId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the rate limiters applied to a network interface.
         * @summary Updates the rate limiters applied to a network interface. Post-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {PartialNetworkInterface} body A subset of the guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGuestNetworkInterfaceByID(ifaceId: string, body: PartialNetworkInterface, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGuestNetworkInterfaceByID(ifaceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
         * @summary Partially updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] A subset of Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMachineConfiguration(body?: MachineConfiguration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMachineConfiguration(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the MMDS data store.
         * @param {object} [body] The MMDS data store patch JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMmds(body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMmds(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the desired state (Paused or Resumed) for the microVM.
         * @summary Updates the microVM state.
         * @param {Vm} body The microVM state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchVm(body: Vm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchVm(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
         * @summary Creates or updates a balloon device.
         * @param {Balloon} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBalloon(body: Balloon, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBalloon(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
         * @summary Creates or updates the boot source. Pre-boot only.
         * @param {BootSource} body Guest boot source properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuestBootSource(body: BootSource, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuestBootSource(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
         * @summary Creates or updates a drive. Pre-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {Drive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuestDriveByID(driveId: string, body: Drive, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuestDriveByID(driveId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates new network interface with ID specified by iface_id path parameter.
         * @summary Creates a network interface. Pre-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {NetworkInterface} body Guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuestNetworkInterfaceByID(ifaceId: string, body: NetworkInterface, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuestNetworkInterfaceByID(ifaceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
         * @summary Creates/updates a vsock device. Pre-boot only.
         * @param {Vsock} body Guest vsock properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuestVsock(body: Vsock, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuestVsock(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initializes the logger by specifying a named pipe or a file for the logs output.
         * @param {Logger} body Logging system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLogger(body: Logger, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLogger(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
         * @summary Updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMachineConfiguration(body?: MachineConfiguration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMachineConfiguration(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initializes the metrics system by specifying a named pipe or a file for the metrics output.
         * @param {Metrics} body Metrics system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMetrics(body: Metrics, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMetrics(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a MMDS (Microvm Metadata Service) data store.
         * @param {object} [body] The MMDS data store as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMmds(body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMmds(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
         * @summary Set MMDS configuration. Pre-boot only.
         * @param {MmdsConfig} body The MMDS configuration as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMmdsConfig(body: MmdsConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMmdsConfig(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
         * @summary Creates a full or diff snapshot. Post-boot only.
         * @param {SnapshotCreateParams} body The configuration used for creating a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot(body: SnapshotCreateParams, options?: any): AxiosPromise<void> {
            return localVarFp.createSnapshot(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a synchronous action.
         * @param {InstanceActionInfo} info 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSyncAction(info: InstanceActionInfo, options?: any): AxiosPromise<void> {
            return localVarFp.createSyncAction(info, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the current balloon device configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeBalloonConfig(options?: any): AxiosPromise<Balloon> {
            return localVarFp.describeBalloonConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the latest balloon device statistics, only if enabled pre-boot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeBalloonStats(options?: any): AxiosPromise<BalloonStats> {
            return localVarFp.describeBalloonStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns general information about an instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeInstance(options?: any): AxiosPromise<InstanceInfo> {
            return localVarFp.describeInstance(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
         * @summary Gets the full VM configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportVmConfig(options?: any): AxiosPromise<FullVmConfiguration> {
            return localVarFp.getExportVmConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the Firecracker version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirecrackerVersion(options?: any): AxiosPromise<FirecrackerVersion> {
            return localVarFp.getFirecrackerVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
         * @summary Gets the machine configuration of the VM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMachineConfiguration(options?: any): AxiosPromise<MachineConfiguration> {
            return localVarFp.getMachineConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the MMDS data store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmds(options?: any): AxiosPromise<object> {
            return localVarFp.getMmds(options).then((request) => request(axios, basePath));
        },
        /**
         * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
         * @summary Loads a snapshot. Pre-boot only.
         * @param {SnapshotLoadParams} body The configuration used for loading a snaphot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSnapshot(body: SnapshotLoadParams, options?: any): AxiosPromise<void> {
            return localVarFp.loadSnapshot(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device.
         * @param {BalloonUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBalloon(body: BalloonUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.patchBalloon(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
         * @summary Updates a balloon device statistics polling interval.
         * @param {BalloonStatsUpdate} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBalloonStatsInterval(body: BalloonStatsUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.patchBalloonStatsInterval(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
         * @summary Updates the properties of a drive. Post-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {PartialDrive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGuestDriveByID(driveId: string, body: PartialDrive, options?: any): AxiosPromise<void> {
            return localVarFp.patchGuestDriveByID(driveId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the rate limiters applied to a network interface.
         * @summary Updates the rate limiters applied to a network interface. Post-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {PartialNetworkInterface} body A subset of the guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGuestNetworkInterfaceByID(ifaceId: string, body: PartialNetworkInterface, options?: any): AxiosPromise<void> {
            return localVarFp.patchGuestNetworkInterfaceByID(ifaceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
         * @summary Partially updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] A subset of Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMachineConfiguration(body?: MachineConfiguration, options?: any): AxiosPromise<void> {
            return localVarFp.patchMachineConfiguration(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the MMDS data store.
         * @param {object} [body] The MMDS data store patch JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMmds(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.patchMmds(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the desired state (Paused or Resumed) for the microVM.
         * @summary Updates the microVM state.
         * @param {Vm} body The microVM state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVm(body: Vm, options?: any): AxiosPromise<void> {
            return localVarFp.patchVm(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
         * @summary Creates or updates a balloon device.
         * @param {Balloon} body Balloon properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBalloon(body: Balloon, options?: any): AxiosPromise<void> {
            return localVarFp.putBalloon(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
         * @summary Creates or updates the boot source. Pre-boot only.
         * @param {BootSource} body Guest boot source properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestBootSource(body: BootSource, options?: any): AxiosPromise<void> {
            return localVarFp.putGuestBootSource(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
         * @summary Creates or updates a drive. Pre-boot only.
         * @param {string} driveId The id of the guest drive
         * @param {Drive} body Guest drive properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestDriveByID(driveId: string, body: Drive, options?: any): AxiosPromise<void> {
            return localVarFp.putGuestDriveByID(driveId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new network interface with ID specified by iface_id path parameter.
         * @summary Creates a network interface. Pre-boot only.
         * @param {string} ifaceId The id of the guest network interface
         * @param {NetworkInterface} body Guest network interface properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestNetworkInterfaceByID(ifaceId: string, body: NetworkInterface, options?: any): AxiosPromise<void> {
            return localVarFp.putGuestNetworkInterfaceByID(ifaceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
         * @summary Creates/updates a vsock device. Pre-boot only.
         * @param {Vsock} body Guest vsock properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuestVsock(body: Vsock, options?: any): AxiosPromise<void> {
            return localVarFp.putGuestVsock(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initializes the logger by specifying a named pipe or a file for the logs output.
         * @param {Logger} body Logging system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLogger(body: Logger, options?: any): AxiosPromise<void> {
            return localVarFp.putLogger(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
         * @summary Updates the Machine Configuration of the VM. Pre-boot only.
         * @param {MachineConfiguration} [body] Machine Configuration Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMachineConfiguration(body?: MachineConfiguration, options?: any): AxiosPromise<void> {
            return localVarFp.putMachineConfiguration(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initializes the metrics system by specifying a named pipe or a file for the metrics output.
         * @param {Metrics} body Metrics system description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMetrics(body: Metrics, options?: any): AxiosPromise<void> {
            return localVarFp.putMetrics(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a MMDS (Microvm Metadata Service) data store.
         * @param {object} [body] The MMDS data store as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMmds(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.putMmds(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
         * @summary Set MMDS configuration. Pre-boot only.
         * @param {MmdsConfig} body The MMDS configuration as JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMmdsConfig(body: MmdsConfig, options?: any): AxiosPromise<void> {
            return localVarFp.putMmdsConfig(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
     * @summary Creates a full or diff snapshot. Post-boot only.
     * @param {SnapshotCreateParams} body The configuration used for creating a snaphot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createSnapshot(body: SnapshotCreateParams, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createSnapshot(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a synchronous action.
     * @param {InstanceActionInfo} info 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createSyncAction(info: InstanceActionInfo, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createSyncAction(info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the current balloon device configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public describeBalloonConfig(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).describeBalloonConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the latest balloon device statistics, only if enabled pre-boot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public describeBalloonStats(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).describeBalloonStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns general information about an instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public describeInstance(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).describeInstance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
     * @summary Gets the full VM configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExportVmConfig(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getExportVmConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the Firecracker version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFirecrackerVersion(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFirecrackerVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
     * @summary Gets the machine configuration of the VM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMachineConfiguration(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMachineConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the MMDS data store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMmds(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMmds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
     * @summary Loads a snapshot. Pre-boot only.
     * @param {SnapshotLoadParams} body The configuration used for loading a snaphot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loadSnapshot(body: SnapshotLoadParams, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loadSnapshot(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
     * @summary Updates a balloon device.
     * @param {BalloonUpdate} body Balloon properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchBalloon(body: BalloonUpdate, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchBalloon(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
     * @summary Updates a balloon device statistics polling interval.
     * @param {BalloonStatsUpdate} body Balloon properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchBalloonStatsInterval(body: BalloonStatsUpdate, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchBalloonStatsInterval(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
     * @summary Updates the properties of a drive. Post-boot only.
     * @param {string} driveId The id of the guest drive
     * @param {PartialDrive} body Guest drive properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchGuestDriveByID(driveId: string, body: PartialDrive, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchGuestDriveByID(driveId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the rate limiters applied to a network interface.
     * @summary Updates the rate limiters applied to a network interface. Post-boot only.
     * @param {string} ifaceId The id of the guest network interface
     * @param {PartialNetworkInterface} body A subset of the guest network interface properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchGuestNetworkInterfaceByID(ifaceId: string, body: PartialNetworkInterface, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchGuestNetworkInterfaceByID(ifaceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
     * @summary Partially updates the Machine Configuration of the VM. Pre-boot only.
     * @param {MachineConfiguration} [body] A subset of Machine Configuration Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchMachineConfiguration(body?: MachineConfiguration, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchMachineConfiguration(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the MMDS data store.
     * @param {object} [body] The MMDS data store patch JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchMmds(body?: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchMmds(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the desired state (Paused or Resumed) for the microVM.
     * @summary Updates the microVM state.
     * @param {Vm} body The microVM state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchVm(body: Vm, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchVm(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
     * @summary Creates or updates a balloon device.
     * @param {Balloon} body Balloon properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putBalloon(body: Balloon, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putBalloon(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
     * @summary Creates or updates the boot source. Pre-boot only.
     * @param {BootSource} body Guest boot source properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putGuestBootSource(body: BootSource, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putGuestBootSource(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
     * @summary Creates or updates a drive. Pre-boot only.
     * @param {string} driveId The id of the guest drive
     * @param {Drive} body Guest drive properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putGuestDriveByID(driveId: string, body: Drive, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putGuestDriveByID(driveId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new network interface with ID specified by iface_id path parameter.
     * @summary Creates a network interface. Pre-boot only.
     * @param {string} ifaceId The id of the guest network interface
     * @param {NetworkInterface} body Guest network interface properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putGuestNetworkInterfaceByID(ifaceId: string, body: NetworkInterface, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putGuestNetworkInterfaceByID(ifaceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
     * @summary Creates/updates a vsock device. Pre-boot only.
     * @param {Vsock} body Guest vsock properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putGuestVsock(body: Vsock, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putGuestVsock(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initializes the logger by specifying a named pipe or a file for the logs output.
     * @param {Logger} body Logging system description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putLogger(body: Logger, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putLogger(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None).
     * @summary Updates the Machine Configuration of the VM. Pre-boot only.
     * @param {MachineConfiguration} [body] Machine Configuration Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putMachineConfiguration(body?: MachineConfiguration, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putMachineConfiguration(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initializes the metrics system by specifying a named pipe or a file for the metrics output.
     * @param {Metrics} body Metrics system description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putMetrics(body: Metrics, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putMetrics(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a MMDS (Microvm Metadata Service) data store.
     * @param {object} [body] The MMDS data store as JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putMmds(body?: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putMmds(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
     * @summary Set MMDS configuration. Pre-boot only.
     * @param {MmdsConfig} body The MMDS configuration as JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putMmdsConfig(body: MmdsConfig, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putMmdsConfig(body, options).then((request) => request(this.axios, this.basePath));
    }
}


